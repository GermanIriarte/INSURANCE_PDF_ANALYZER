<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Dashboard - Comparador Inteligente</title>
  <link rel="stylesheet" href="Analyzer.css">
</head>
<body>
  <!-- Header con logo, saludo y cierre de sesión -->
  <header class="header">
    <div class="container header-container">
      <div class="logo">Comparador Inteligente</div>
      <div class="user-info">
        <span>Hola, tú</span>
        <a href="index.html" class="btn-logout">Cerrar sesión</a>
      </div>
    </div>
  </header>

  <!-- Dashboard principal con tres secciones centradas -->
  <main class="container dashboard">
    <!-- Paso 1: Subir PDFs -->
    <section class="card section-upload">
      <h2>Paso 1: Subir PDFs</h2>
      <form id="uploadForm">
        <label for="pdfInput" class="file-label">
          ⊕ Arrastra tus archivos o haz clic aquí
          <input type="file" id="pdfInput" name="files" accept="application/pdf" multiple required aria-describedby="filesSummary"/>
        </label>
        <div class="files-summary" id="filesSummary" hidden>0 archivos seleccionados</div>
        <ul id="fileList" class="file-list" aria-live="polite"></ul>
        <button type="submit" class="btn-action" disabled>Subir archivos</button>
      </form>
      <div id="uploadResponse" class="response-area"></div>
    </section>

    <!-- Paso 2: Descargar hoja (Excel/Sheets) -->
    <section class="card section-excel">
      <h2>Paso 2: Descargar hoja (Excel/Sheets)</h2>
      <button id="downloadSheetBtn" class="btn-action" disabled>Descargar hoja</button>
      <div id="excelResponse" class="response-area"></div>
    </section>

    <!-- Paso 3: Descargar informe PDF -->
    <section class="card section-word">
      <h2>Paso 3: Descargar informe PDF</h2>
      <button id="downloadPdfBtn" class="btn-action" disabled>Descargar PDF</button>
      <div id="wordResponse" class="response-area"></div>
    </section>
  </main>

  <!-- Footer fijo al fondo -->
  <footer class="footer">
    <div class="container">
      <p>© 2025 Comparador Inteligente. Todos los derechos reservados.</p>
    </div>
  </footer>

  <!-- Scripts para manejar eventos -->
  <script>
    const uploadForm = document.getElementById('uploadForm');
    const excelBtn   = document.getElementById('downloadSheetBtn');
    const wordBtn    = document.getElementById('downloadPdfBtn');

    // Webhook POST (análisis)
    const webhookUrl = 'https://n8n.149-130-187-171.sslip.io/webhook/3034612b-c6ad-4372-871e-8a65ffc8b626';

    // Deriva la base de n8n (usa /webhook-test si el POST también es test)
    //construir una url base para la deacarga, creando una url absoluta y añadiendo webhook test o webhook dependiendo del origen
    const N8N_BASE = (() => {
      try {
        const u = new URL(webhookUrl);
        const isTest = u.pathname.startsWith('/webhook-test/');
        return `${u.origin}${isTest ? '/webhook-test' : '/webhook'}`;
      } catch {
        return (location.hostname === 'localhost')
          ? 'http://localhost:5678/webhook-test'
          : `${location.origin}/webhook`;
      }
    })();

    // === Autenticación Basic (en memoria) ===  
    let AUTH_HEADER = null;

    async function pedirCredenciales() {
      const user = prompt('Usuario:');
      const pass = prompt('Contraseña:');
      if (!user || !pass) throw new Error('Se requiere autenticación');
      AUTH_HEADER = 'Basic ' + btoa(`${user}:${pass}`); //se cifra user, y pass en base64 con el objetivo de que navegue en el header del url http. 
    } //se guarda en Authheader la construccion de la cadena con usuario y contraseña siempre y cuando sean campos no vacios. 

    // Wrapper fetch con Authorization + reintento ante 401
    async function fetchAuth(url, opts = {}, reintento = false) {
      const headers = new Headers(opts.headers || {});
      if (AUTH_HEADER) headers.set('Authorization', AUTH_HEADER); //agregamos en el header la autenticacion. 
      const res = await fetch(url, { ...opts, headers, cache: 'no-store' });
      if (res.status === 401 && !reintento) {
        try { await pedirCredenciales(); } catch {}
        return fetchAuth(url, opts, true);
      }
      return res; //aqui se valida la autenticacion segun el Auth ingresado haciendo fetch a la url. 
    }

    // Utilidades de descarga
    function descargarBlob(blob, nombre) {
      const url = URL.createObjectURL(blob); //crea una url temporal que aputna al blob (archivo binario)
      const a = document.createElement('a');
      a.href = url; //creamos un elemento anchor y hacemos que apunte a un url.
      a.download = nombre || 'archivo';
      document.body.appendChild(a);
      a.click();
      a.remove();
      URL.revokeObjectURL(url);
    } //recibe un archivo binario (Blob), genera una URL temporal en memoria y simula un clic, en un enlace invisible
    //  para que el navegador muestre la descarga con el nombre indicado; luego limpia todo liberando la URL.

    function nombreDesdeDisposition(res, fallback = 'archivo') {
      const cd = res.headers.get('Content-Disposition') || res.headers.get('content-disposition') || '';
      const m = /filename\*=UTF-8''([^;]+)|filename="?([^";]+)"?/i.exec(cd);
      try {
        if (m && m[1]) return decodeURIComponent(m[1]);
        if (m && m[2]) return m[2];
      } catch {}
      return fallback;
    }  //esta funcion intenta extraer el nombre del erchvio desde el los headers. 

    // Pedir credenciales al cargar
    (async () => {
      try { await pedirCredenciales(); } catch {}
    })();

    // URL de descarga XLSX: si el POST te dio sheetUrl, úsalo; si no, endpoint fijo
    function getXlsxUrl() {
      return (window.sheetUrl && String(window.sheetUrl)) || `${N8N_BASE}/download/xlsx?t=${Date.now()}`;
    }

    const excelResp = document.getElementById('excelResponse');
    const wordResp  = document.getElementById('wordResponse');

    if (excelBtn) excelBtn.disabled = true; //no se puede interactuar con el
    if (wordBtn)  wordBtn.disabled  = true;

    const fileInput    = document.getElementById('pdfInput');
    const fileLabel    = document.querySelector('.section-upload .file-label');
    const fileListEl   = document.getElementById('fileList');
    const filesSummary = document.getElementById('filesSummary');
    const submitBtn    = document.querySelector('#uploadForm .btn-action');

    let selectedFiles = []; // fuente de verdad

    function updatePreview() {
      selectedFiles = selectedFiles.filter(f => f.type === 'application/pdf' || f.name.toLowerCase().endsWith('.pdf')); // filtra solo pdfs validos.

      const totalMB = selectedFiles.reduce((a,f)=>a+f.size,0) / (1024*1024); //calcula el peso en megabytes.
      const hasFiles = selectedFiles.length > 0;

      filesSummary.hidden = !hasFiles;
      if (hasFiles) {
        filesSummary.textContent = `${selectedFiles.length} archivo${selectedFiles.length===1?'':'s'} · ${totalMB.toFixed(1)} MB`;
      }  //si se tiene archivos en text content imprimimos cuantos y cuantos pesan. 

      fileListEl.innerHTML = selectedFiles.map((f, i) =>
        `<li class="file-item">
           <span>${f.name}</span>
           <button type="button" aria-label="Quitar ${f.name}" data-remove="${i}">×</button>
         </li>`
      ).join(''); // agregamos una lista con cada archivo y una opcion de remove. 

      submitBtn.disabled = !hasFiles;
      if (excelBtn) excelBtn.disabled = true; // se habilita tras el POST exitoso, despues de que hasfiles >0
    }

    fileInput.addEventListener('change', (e) => {
      selectedFiles = Array.from(e.target.files);
      updatePreview();
    });


    //dragenter → detecta cuando el cursor con el archivo entra en la zona.
    //dragover → permite mantener activo el estilo mientras el cursor está encima y además habilita que se pueda soltar ahí (si no haces preventDefault(), el navegador no permite drop).
    //dragleave → detecta cuando el archivo salió de la zona sin soltarlo. Así quitas el estilo “activo”. drop → detecta cuando realmente suelta(s) el archivo dentro de la zona.
    ['dragenter','dragover'].forEach(ev =>
      fileLabel.addEventListener(ev, (e) => { e.preventDefault(); e.stopPropagation(); fileLabel.classList.add('dragover'); })
    ); //permitimos eventos para arrastrar archvios en el fileLabel (input), evitamos el comportamiento por defecto que es que se abren , 

    ['dragleave','drop'].forEach(ev =>
      fileLabel.addEventListener(ev, (e) => { e.preventDefault(); e.stopPropagation(); fileLabel.classList.remove('dragover'); })
    );

    fileLabel.addEventListener('drop', (e) => {
      selectedFiles = Array.from(e.dataTransfer.files);
      updatePreview();
    });

    fileListEl.addEventListener('click', (e) => {
      if (e.target.matches('button[data-remove]')) {
        const idx = Number(e.target.getAttribute('data-remove'));
        selectedFiles.splice(idx, 1);
        updatePreview();
      }
    });

      uploadForm.addEventListener('submit', async (e) => {
      e.preventDefault();

      // Evita doble-click mientras envías
      if (uploadForm.dataset.loading === '1') return;
      uploadForm.dataset.loading = '1';

      // Estado inicial (limpia y bloquea)
      window.sheetUrl = null;
      window.pdfUrl   = null;
      if (wordBtn)  wordBtn.disabled  = true;
      if (excelBtn) excelBtn.disabled = true;
      if (wordResp)  wordResp.textContent  = 'Generando PDF...';
      if (excelResp) excelResp.textContent = '';

      try {
        // Timeout opcional (10 min) para el POST
        const ac = new AbortController();
        const to = setTimeout(() => ac.abort(new Error('timeout')), 700000);

        // Prepara FormData
        const files = selectedFiles.length ? selectedFiles : Array.from(fileInput.files);
        if (!files.length) throw new Error('Selecciona al menos un PDF.');
        const fd = new FormData(); //formdata sirve para empaquetar datos y enviar por pteicion http. 
        files.forEach(f => fd.append('files', f)); //añadimos cada archvio al form data

        const res = await fetchAuth(webhookUrl, { method: 'POST', body: fd, signal: ac.signal }); // enviamos en el body los rhcivos al webhook
        clearTimeout(to);
        if (!res.ok) throw new Error(`POST falló (${res.status})`);

        // Parse robusto
        const ct = res.headers.get('content-type') || ''; //guardamos en que formato viene la repsuesta 
        const data = ct.includes('application/json') ? await res.json() : JSON.parse(await res.text());

        // Actualiza y NORMALIZA URLs al origen de n8n, este bloque es el que se 
        // encarga de tomar las URLs que devuelve n8n y adaptarlas para que funcionen en el frontend.

        window.sheetUrl = data.sheetUrl || data.excelUrl || null;
        window.pdfUrl   = data.pdfUrl   || data.wordUrl  || data.pdfPath || null;// buscamos el url del archivo de diferentes maneras

        
        
        const base = new URL(N8N_BASE).origin; // ej: https://n8n.149-130-187-171.sslip.io, arreglamos la url, agragandole la base. 
        if (window.sheetUrl) {
          if (window.sheetUrl.startsWith('/')) window.sheetUrl = base + window.sheetUrl; //si el servidor devolvio url relativa agragamos base.
          window.sheetUrl = window.sheetUrl.replace(/^http:\/\/localhost:5678/, base);
        }
        if (window.pdfUrl) {
          if (window.pdfUrl.startsWith('/')) window.pdfUrl = base + window.pdfUrl;
          window.pdfUrl = window.pdfUrl.replace(/^http:\/\/localhost:5678/, base);
        }

        // Habilita botones y mensajes
        excelBtn.disabled = false;
        excelResp.textContent = 'Hoja lista para descargar.';

        if (window.pdfUrl) {
          wordBtn.disabled = false;
          wordResp.textContent = 'PDF listo para descargar.';
        } else {
          wordBtn.disabled = true;
          wordResp.textContent = 'No se recibió URL de PDF.';
        }

        document.getElementById('uploadResponse').innerText = JSON.stringify(data, null, 2);
      } catch (err) {
        console.error(err);
        const msg = err?.message === 'timeout'
          ? 'La generación tardó demasiado. Inténtalo de nuevo.'
          : `Error generando el PDF: ${err?.message || 'desconocido'}`;
        if (wordResp) wordResp.textContent = msg;
        document.getElementById('uploadResponse').innerText = (err && (err.stack || err.message)) || String(err);
      } finally {
        uploadForm.dataset.loading = '0';
        submitBtn.disabled = !selectedFiles.length;
      }
    });

    // Descargar PDF con Auth
    wordBtn.onclick = async () => {
      if (!window.pdfUrl) { alert('Aún estamos generando el PDF…'); return; }
      try {
        wordBtn.disabled = true;
        const res = await fetchAuth(window.pdfUrl, { cache: 'no-store' });
        if (!res.ok) throw new Error('No se pudo obtener el PDF');
        const blob = await res.blob();
        const nombre = nombreDesdeDisposition(res, (new URL(window.pdfUrl)).searchParams.get('name') || 'Analisis.pdf');
        descargarBlob(blob, nombre);
      } catch (err) {
        alert(err.message || 'Error descargando el PDF');
      } finally {
        wordBtn.disabled = false;
      }
    };

    // Descargar XLSX con Auth (ya no se usa navegación directa)
    excelBtn.onclick = async () => {
      const url = getXlsxUrl();
      if (!url) { alert('Aún no hay hoja lista. Sube los PDFs primero.'); return; }
      try {
        excelBtn.disabled = true;
        const res = await fetchAuth(url, { cache: 'no-store' });
        if (!res.ok) throw new Error('No se pudo obtener la hoja');
        const blob = await res.blob();
        const nombre = nombreDesdeDisposition(res, 'Comparador.xlsx');
        descargarBlob(blob, nombre);
      } catch (e) {
        alert(e.message || 'Error descargando la hoja');
      } finally {
        excelBtn.disabled = false;
      }
    };
  </script>
</body>
</html>